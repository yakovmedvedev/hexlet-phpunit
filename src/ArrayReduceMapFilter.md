

$numbers = [-25, 1, 2, 3, 4, 5, 6, 7, 8, 9];

$newNumbers = array_map(fn($number) => $number + 2, $numbers);
print_r($newNumbers);

$users = [
    ['name' => 'Igor', 'age' => 19],
    ['name' => 'Danil', 'age' => 4],
    ['name' => 'Vovan', 'age' => 4],
    ['name' => 'Matvey', 'age' => 16],
];
usort($users, fn($a, $b) => $a['age'] <=> $b['age']);
print_r($users);

usort($users, fn($a, $b) => $a['name'] <=> $b['name']);
print_r($users);

//FILTER
$filtered = array_filter($children, fn($child) => isDirectory($child));
//Общая схема кода при фильтрации практически такая же, как и в отображении. Отличается только пара ключевых моментов:
//
//Фильтрация возвращает коллекцию либо того же размера (если ничего не было отфильтровано), либо меньшего.
//Она может вернуть даже пустую коллекцию, если ни один из элементов не подошел
//Фильтрация всегда возвращает исходные элементы. Она никогда не делает отображение. Если на вход фильтрации поступил
//список пользователей, то список пользователей будет и на выходе
// Порядок аргументов обратный
// Сначала идет коллекция, а затем — функция
// $user – это элемент массива $users
$filteredUsers = array_filter($users, fn($user) => $user['age'] > 10);
//В отличие от array_map, переданная в array_filter функция должна быть предикатом.
//Другими словами, она должна вернуть true или false для каждого элемента коллекции.
//Значение, которое возвращается никак не используется. Оно всего лишь говорит о том,
//стоит ли включать текущий элемент в итоговый массив. Новички часто делают ошибку на этом этапе
//и начинают возвращать из фильтра то, что они бы хотели увидеть в результирующем массиве.
//На самом деле, для этого надо применять array_map.


//MAP
$names = array_map(fn($user) => $user['name'], $users);
print_r($names);// => ['Igor', 'Danil', 'Vovan', 'Matvey']
//Функция array_map принимает два параметра:
//Колбэк-функцию
//Коллекцию, которая будет отображаться
//Дальше внутри себя array_map делает перебор элементов переданной коллекции и для каждого элемента вызывает
// колбэк-функцию. На вход этой функции передается элемент исходного массива, а ее результат записывается
// в новый массив, который и возвращается наружу.
//
//Возвращаемый массив всегда такого же размера, как и исходный, потому что array_map отображает каждый элемент
// исходного массива в элемент возвращаемого
//Внутри анонимной функции можно выполнять любые вычисления, а не только возвращать часть исходного элемента
//Функция array_map полностью скрывает от нас наличие обхода и процесс сборки нового массива
$numbers = [5, 2, 3];
// Возводим в квадрат каждое число
$newNumbers = array_map(fn($number) => $number ** 2, $numbers);
print_r($newNumbers); // => [25, 4, 9]


$cmp = function($a, $b) {
    if ($a['age'] === $b['age']) {
        return 0;
    }
    return $a['age'] > $b['age'] ? 1 : -1;
};

$dividedNum = array_map(fn ($number) => $number / 2, $numbers);
print_r($dividedNum);

//REDUCE
//Функция array_reduce принимает на вход три параметра.
//Два из них уже традиционны — это коллекция и функция-обработчик,
//а вот третьим выступает начальное значение аккумулятора.

$oldest = array_reduce($users, function ($acc, $user) {
    return $user['age'] > $acc['age'] ? $user : $acc;
}, $users[0]);
print_r($oldest);

//Колбэк-функция, передаваемая в array_reduce — это самая важная часть
//и ключ к пониманию работы всего механизма агрегации.
//Она принимает на вход два значения://
//Текущее значение аккумулятора
//Текущий обрабатываемый элемент
//Задача функции — вернуть новое значение аккумулятора.
//При этом array_reduce никак не анализирует содержимое аккумулятора.
//Все, что она делает — она передает значение аккумулятора в каждый новый вызов,
//пока не будет обработана вся коллекция, и в конце концов вернет его наружу.
//Подчеркнем, что возвращать аккумулятор надо всегда, даже если он не изменился.

$least = array_reduce($numbers, function ($acc, $number) {
    return max($number, $acc);
}, $numbers[0]);
print_r($least);

//Код практически не изменился.
// Как видите, ушел цикл и появился возврат аккумулятора из анонимной функции.
$usersByAge = array_reduce($users, function ($acc, $user) {
    $acc[$user['age']][] = $user['name'];
    return $acc;
}, []);
print_r($usersByAge);
//function myReduce($coll, callable $callback, $init = null)
//{
//    $acc = $init;
//    foreach ($coll as $item) {
//        $acc = $callback($acc, $item); // Заменяем старый аккумулятор новым
//    }
//    return $acc;
//}